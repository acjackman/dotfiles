#!/usr/bin/env zsh

# Fast-forward the default branch without switching to it
# Works whether the branch has a worktree or not
#
# Usage: ,gff

# Lock variables and helper functions
local LOCK_FILE GIT_DIR

__acquire_lock() {
    # Get absolute git directory path (handles worktrees correctly)
    GIT_DIR=$(git rev-parse --absolute-git-dir 2>/dev/null)
    [[ -z "$GIT_DIR" ]] && { echo "ERROR: Not in a git repository" >&2; return 1; }

    LOCK_FILE="${GIT_DIR}/,gff.lock"

    # Retry loop (60 seconds max)
    local max_retries=60 retry_count=0 lock_pid
    while (( retry_count < max_retries )); do
        # Check if lock exists
        if [[ ! -f "$LOCK_FILE" ]]; then
            # Create lock with current PID and timestamp
            echo "$$" > "$LOCK_FILE"
            date +%s >> "$LOCK_FILE"
            return 0
        fi

        # Lock exists - check if stale
        lock_pid=$(head -1 "$LOCK_FILE" 2>/dev/null)
        if [[ "$lock_pid" =~ ^[0-9]+$ ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
            # Stale lock (PID not running) - remove and retry
            rm -f "$LOCK_FILE"
            continue
        fi

        # Lock held by running process - wait
        (( retry_count == 0 )) && echo "Waiting for other ,gff instance to finish..." >&2
        sleep 1
        (( retry_count++ ))
    done

    # Timeout
    echo "ERROR: Failed to acquire lock after ${max_retries}s (held by PID: $lock_pid)" >&2
    return 1
}

__cleanup_lock() {
    [[ -f "$LOCK_FILE" ]] && rm -f "$LOCK_FILE"
}

# Acquire lock before proceeding
__acquire_lock || return 1

# Register cleanup handler
trap '__cleanup_lock' EXIT INT TERM

# Find default branch
# Priority 1: Try worktrunk if available
if command -v wt >/dev/null 2>&1; then
    default_branch=$(wt config state default-branch 2>/dev/null)
fi

# Priority 2: Try git symbolic-ref
if [ -z "$default_branch" ]; then
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
fi

# Priority 3: Fallback to common names
if [ -z "$default_branch" ]; then
    if git show-ref --verify --quiet refs/heads/main; then
        default_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        default_branch="master"
    else
        echo "ERROR: Could not determine default branch" >&2
        return 1
    fi
fi

echo "Default branch: $default_branch" >&2

# Check if branch has a worktree
worktree_path=$(git worktree list --porcelain | grep -B 2 "branch refs/heads/$default_branch" | grep "^worktree" | cut -d' ' -f2)

if [ -n "$worktree_path" ]; then
    # Branch has a worktree - update it
    echo "Updating worktree at: $worktree_path" >&2
    echo "Fetching $default_branch from origin..." >&2
    git -C "$worktree_path" fetch origin "$default_branch" && \
    git -C "$worktree_path" merge --ff-only "origin/$default_branch"
else
    # No worktree - update branch ref directly
    echo "Updating branch ref (no worktree)" >&2
    git fetch origin "$default_branch:$default_branch"
fi
